

[[SQL]]

# Индексы
> [Индексы в PostgreSQL — 1](https://habr.com/ru/companies/postgrespro/articles/326096/)
> [Погружение в индексы PostgreSQL](https://habr.com/ru/companies/otus/articles/747882/)
> > [Индексы в PostgreSQL](https://tproger.ru/articles/indeksy-v-postgresql)

## Общее

По умолчанию PostgreSQL осуществляет поиск по столбцам [[Алгоритмы#Полный перебор|полным перебором]]. При больших объемах данных это может занимать продолжительное время. Эту проблему решает индексация.

Индексы таблице это по сути еще одна таблица с ключем (он генерируется в зависимости от алгоритма и данных таблицы) и ссылкой на строку таблицы

Преимущества:
- ускоряет определенный вид поиска по полю таблицы
Недостатки:
- при каждой операции вставки/удаления/изменения (если это затрагивает проиндексированный столбец) таблица должна переиндексироваться


Структура запроса для индексации:
```sql
CREATE INDEX 'Имя индекса' ON 'Название таблицы' USING 'метод индексации' ('Название столбца');
```
%% 
Примечание:
- Имя индекса должно быть уникально в рамках схемы поэтому рекомендую паттерн `idx_'Название таблицы'_'Название столбца'`
- `USING 'метод индексации'` можно не указывать. по умолчанию будет использоваться `btree` 
- вы можете создавать несколько индексов по 1 столбцу или делать индексацию не по всему столбцу (например проиндексировать имя пользователя 2 раза не полностью в зависимости от параметра active ). это снижает размер и ускоряет поиск
%%

## Когда индекс не нужен (или вреден)

- Таблица маленькая (десятки/сотни строк) — последовательное сканирование быстрее.
- Низкая селективность (например, `WHERE is_active = true`, когда 95% строк активны) — делай partial.
- Столбец часто обновляется — индекс приведёт к большим издержкам записи.
- Условие несопоставимо с методом (`LIKE '%abc'` без `pg_trgm`, функции без expression index).
- Ненужные дубликаты композитных индексов (правые префиксы): `btree(a,b)` уже частично покрывает `a`.

## Список индексов:
### B-tree (сбалансированное дерево)
Рекомендуется для большинства случаев — универсальный и сбалансированный вариант.

 Подходит для:
- Проверок на равенство (`=`)
- Сравнений (`>`, `<`, `>=`, `<=`)
- Диапазонов (`BETWEEN`)
- Сортировок (`ORDER BY`)


```sql
CREATE INDEX ix_example_btree ON example_table (column_name);
```

 [[Алгоритмы#B-tree|Принцип работы]]


### GIN (Generalized Inverted Index)
Рекомендуется для текстовых и JSONB полей, где нужен поиск по вхождениям.

Подходит для:
- Полнотекстового поиска (`to_tsvector`, `@@`)
- Поиска по массивам (`@>`, `<@`, `&&`)
- JSONB-полям

### Hash
Быстрее B-tree при чистом `=` сравнении, но **менее универсален**. Прирост скорости по сравнению с B-tree не велик

Подходит для:
- Проверок **только на равенство** (`=`)

```sql
CREATE INDEX ix_example_hash ON example_table USING hash (column_name);
```

### GiST (Generalized Search Tree)
 **Выбор для сложных типов данных**: координаты, диапазоны, геометрия
 
 Подходит для:
- Географических и геометрических данных (PostGIS)
- Полнотекстового поиска (альтернатива GIN)
- Поиска по диапазонам и близости (`<->` — расстояние)

### SP-GiST (Space-partitioned GiST)
Более специализированный, чем GiST, но быстрее для некоторых типов.
### Подходит для:
- Пространственных данных (2D, 3D)
- Данных с естественной кластеризацией (например, иерархических)


### BRIN (Block Range INdex)
Индекс очень компактный и быстрый при чтении последовательных диапазонов.

Подходит для:
- Очень больших таблиц, где данные хранятся **в порядке вставки**
- Полей, где значения коррелируют с физическим порядком строк (например, `created_at`, `id`)

# Транзакции и уровни изоляции

#TODO подробно описать тему в [[SQL]] и ссылаться на неё

**Транзакция** - это последовательный  набор операций 

В PostgreSQL транзакции  удовлетворяют  [[Требования ACID|требованиям ACID]] в зависимости от уровня изоляции:

| Уровень изоляции     | Грязное чтение | Неповторяющееся чтение | Фантомное чтение | Другие аномалии |
| -------------------- | -------------- | ---------------------- | ---------------- | --------------- |
| **Read Uncommitted** | ❌              | ✅                      | ✅                | ✅               |
| **Read Committed**   | ❌              | ✅                      | ✅                | ✅               |
| **Repeatable Read**  | ❌              | ❌                      | ❌                | ✅               |
| **Serializable**     | ❌              | ❌                      | ❌                | ❌               |
|                      |                |                        |                  |                 |

#### Примеры транзакций:

```sql
-- ОБЫЧНАЯ ТРАНЗАКЦИЯ
/* Начать транзакцию*/
BEGIN TRANSACTION; /* ИЛИ */ BEGIN;

COMMIT; -- Подтверддаем изменения
/* ИЛИ */
ROLLBACK; -- Вызываен ошибку и откатываем всю транзакцию

---------------------------------------------------

-- Частичный откат
BEGIN;

SAVEPOINT "Наше название точки";

ROLLBACK TO SAVEPOINT "Наше название точки"; -- Вызываен ошибку и откатываем все что идет после SAVEPOINT

---------------------------------------------------

-- ТРАНЗАКЦИЯ с указанием уровнем изоляции
BEGIN TRANSACTION ISOLATION LEVEL "уровень";

/*Завершить изменения*/
COMMIT;

---------------------------------------------------

-- ТРАНЗАКЦИЯ с указанием уровнем изоляции ВНУТРИ ТРАНЗАКЦИИ
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

/*Завершить изменения*/
COMMIT;

```

Уровни:
- ~~READ UNCOMMITTED - не имеет смысл указывать так как в посдгрес он идентичен READ UNCOMMITTED~~
- ~~READ UNCOMMITTED -  не имеет смысл указывать так как это значение по умолчанию~~
- REPEATABLE READ
- SERIALIZABLE

# пакетная загрузка данных
#TODO

# аналитические запросы, профилирование
#TODO