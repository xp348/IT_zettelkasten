> Источники:
> [Классификация парадигм программирования](https://habr.com/ru/articles/905292/)
---
# Объектно-ориентированное программирование (ООП)
>Источники:
> [Объектно-ориентированное программирование. Классы и объекты](https://pythonworld.ru/osnovy/obektno-orientirovannoe-programmirovanie-obshhee-predstavlenie.html)
> [Концепция ООП простыми словами | Объектно-ориентированное программирование Python](https://youtu.be/Z7AY41tE-3U?si=wZ9sUphCGjzZj-rm)
> [Полиморфизм (информатика)](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
> [# ООП в картинках](https://habr.com/ru/articles/463125/)
> 
---

концепция ООП основывается на понятиях **Класс** и **Объект**
**Класс** — тип, описывающий устройство объектов. 
**Объект** — это экземпляр класса.

методы класса - функции внутри класса
атрибуты - переменные предаваемые внутрь функции

Принципы:
1. Инкапсуляция - у классов есть переменные, атрибуты, методы класса которые доступны только внутри класса и не могут изменены из вне
2. Наследование - частные случае классов наследуются от общих
3. Полиморфизм - способность через единый интерфейс работать с разными типами данных. Разные источники выделяют разные классификации полиморфизма:
	- параметрический
	- включения
	- перегрузка
	- Приведение (преобразование) типа
4. Абстракция -  выделение общих характеристик объекта и сокрытие деталей реализации, которые не важны снаружи.. (не все источники выделяют этот принцип в ООП )

## Примеры на Python
Класс и Объект и их методы:
```python
class Cat:
    def __init__(self,name: str):
        self.name = name

    def getName(self):
        return self.name

barsik = Cat(name="Барсик")

print(barsik.getName()) # Барсик
```

Инкапсуляция:
чтобы объявить приватную переменную/функцию добавьте в ее начало `__`. Приватность в питоне носит условный характер. Ты все еще можешь получить доступ к значению добавив в начале переменной/функции при обращении `_НазваниеКласса`
```python
class Cat:
    def __init__(self, name: str):
        self.__name = name  # Двойное подчеркивание — делает атрибут "приватным"

    def get_name(self):
        """Геттер для имени"""
        return self.__name
        
    def __set_name(self, new_name: str):
        """Приватный метод — устанавливает имя с проверкой"""
        if self.__validate_name(new_name):
            self.__name = new_name
        else:
            print("Ошибка: имя должно быть непустой строкой.")

    def __validate_name(self, name: str) -> bool:
        """Приватный метод — проверяет корректность имени"""
        return isinstance(name, str) and name.strip() != ""

# Использование
barsik = Cat(name="Барсик")
print(barsik.get_name())  # Барсик
barsik.name = ""  # Это просто создаст новый публичный атрибут name, а не изменит __name
print(barsik.get_name())  # Барсик (осталось прежним)
print(barsik._Cat__name)  # Барсик 
```

Инкапсуляция:
```python
# Родительский класс
class Pet:
    def __init__(self, name: str):
        self.name = name

    def getName(self):
        return self.name

    def speak(self):
        return "Какой-то звук"

# Дочерний класс

class Cat(Pet):
    def __init__(self, name: str, color: str):
        # Вызов конструктора родителя
        super().__init__(name)
        self.color = color  # дополнительный атрибут, специфичный для кота

    # Переопределение метода (полиморфизм)
    def speak(self):
        return "Мяу!"

# Использование
barsik = Cat(name="Барсик", color="серый")

print(barsik.getName())  # Барсик (унаследовано от Pet)
print(barsik.speak())  # Мяу! (переопределено в Cat)
print(barsik.color)  # серый (новое свойство Cat)
```

Полиморфизм:
```python
"""
1. Параметрический полиморфизм
Один и тот же код работает с объектами разных типов, если они поддерживают нужные операции.  
(В Python это называется “утиная типизация” — duck typing).
"""

def show_length(obj):
    print(len(obj))
    
show_length("Барсик")     # 6 (строка)
show_length([1, 2, 3])    # 3 (список)
show_length({1: "a", 2: "b"})  # 2 (словарь)

"""
2. Полиморфизм включения (наследования)
Разные классы-потомки могут переопределять методы родителя, но вызывать их можно одинаково.
"""
class Pet:
    def speak(self):
        return "Какой-то звук"

class Cat(Pet):
    def speak(self):
        return "Мяу!"

class Dog(Pet):
    def speak(self):
        return "Гав!"

pets = [Cat(), Dog(), Pet()]

for pet in pets:
    print(pet.speak())  # Мяу! / Гав! / Какой-то звук
    
    
"""
3. Перегрузка (overloading)
Одинаковое имя функции или оператора, но разное поведение в зависимости от типа или числа аргументов.  
В классическом виде (как в C++/Java) Python **не поддерживает перегрузку методов напрямую,  но можно имитировать её через _значения по умолчанию_ или _`*args` / `**kwargs`_.
"""
class Math:
    def add(self, a, b=0, c=0):
        return a + b + c

m = Math()
print(m.add(2))        # 2
print(m.add(2, 3))     # 5
print(m.add(2, 3, 4))  # 9

"""
Приведение (преобразование) типов
Преобразование одного типа данных в другой — тоже форма полиморфизма,  
потому что объекты разных типов могут участвовать в общих операциях после преобразования.
"""
x = "123"
y = int(x)     # строка → целое число
z = float(y)   # целое → число с плавающей точкой

print(x, type(x))  # 123 <class 'str'>
print(y, type(y))  # 123 <class 'int'>
print(z, type(z))  # 123.0 <class 'float'>

```

Абстракция:
```python
from abc import ABC, abstractmethod

class Pet(ABC):
    """Абстрактный класс — определяет интерфейс для всех питомцев"""

    @abstractmethod
    def speak(self):
        """Абстрактный метод — должен быть реализован в подклассе"""
        pass


class Cat(Pet):
    def speak(self):
        return "Мяу!"

  
class Dog(Pet):
    def speak(self):
        return "Гав!"

  
# Работа через абстракцию (общий интерфейс)
def make_sound(pet: Pet):
    print(pet.speak())

  
# Использование
make_sound(Cat())  # Мяу!
make_sound(Dog())  # Гав!
```

---

# Декларативное программирование 
---

# Императивное программирование 
---
# Структурное программирование
---
# Функциональное программирование
---
# Логическое программирование

---


