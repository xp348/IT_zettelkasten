## **SOLID**
> [Принципы проектирования SOLID с примерами на Python](https://habr.com/ru/companies/otus/articles/651753/)
---
- **S**ingle Responsibility Principle (Принцип единственной ответственности) - 
- **O**pen‐Closed Principle (Принцип открытости/закрытости)
- **L**iskov Substitution Principle (Принцип подстановки Барбары Лисков)
- **I**nterface Segregation Principle (Принцип разделения интерфейсов)
- Dependency Inversion Principle (Принцип инверсии зависимостей)
####  Принцип единственной ответственности
У каждого класса должна быть только одна «ответственность» и он не должен брать на себя другие обязанности.

%% Например если ты пишешь класс который отвечает за взаимодействие с бд то он не должен отвечать за валидацию данных которые ты хочешь отправить или получить из бд %%

Обрати внимание что разделение ответственности осуществляется не по сущностям а по операциям над сущностью.

%% Например если ты создашь класс который парсит юзиров и сохраняет их в бд и класс который парсит кампании и сохраняет их в бд то это нарушение этого принципа а создание классов которые отвечают за парсинг и за сохранение в бд соответствуют принципу %%

####  Принцип открытости/закрытости
Сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений - то есть нужно писать код так чтобы при появлении новых бизнес требование мы код дописывали а не переписывали

%% например если мы создадим класс который считает скиду на футболки, штаны, брюки и тп то мы  соблюдём `принцип единственной ответственности` но `нарушим принцип открытости/закрытости` так как если нам нужно добавить подсчет скидки на новый товар то нужно будет изменить созданный класс. Лучше создать базовый класс подсчета скидки и наследуясь от него реализовать классы подсчета скидки для каждого отдельного товара %%

####  Принцип подстановки Барбары Лисков
Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы.

%% Например если у нас есть класс Animal и класс Cat который наследуется от класса Animal то весь функционал который работает с классом Animal должен работать и с классом Cat %%

####  Принцип разделения интерфейсов
Ни один клиент не должен зависеть от методов, которые он не использует.

В моем представлении это частный случай `Принцип единственной ответственности`.  
%% Например если у нас есть класс Animal и класс Cat который наследуется от класса Animal а в классе Animal объявлен метод - длинна хвоста. когда мы используем Animal как родительский класс для Cat все в порядке но если мы захотим создать класс Bird и наследоваться от Animal то столкнёмся с проблемами %%

####  Принцип инверсии зависимостей
Принцип инверсии зависимостей гласит:
1. Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций. 
2. Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

Если  код уже реализует принципы `открытости/закрытости` и `подстановки Лисков`, он уже будет неявно согласован с принципом инверсии зависимостей.

## **KISS**
>[KISS — принцип проектирования, содержащий все остальные принципы проектирования](https://habr.com/ru/articles/249639/)
---

KISS (keep it simple and straightforward - будьте проще и понятнее) – это очень общий и абстрактный принцип проектирования, который содержит в себе практически все остальные принципы проектирования.

## **DRY**
>[Don't Repeat Yourself: Как правильно использовать принцип DRY в разработке ПО](https://habr.com/ru/articles/807761/)
---

DRY – это принцип разработки программного обеспечения, призванный минимизировать дублирование информации в коде.

%% Примечание: не надо впадать в фанатизм. Если вы видите что в двух частях проекта есть похожий код но эти части никак не перекликаются логически то не надо выносить этот код в отдельную сущность. С развитием проекта эти  части могут сильно видоизмениться и вынесенный модуль будет только мешать. такое дуюлирование называют `accidental duplication (Случайное дублирование)`%%

Three Strikes And You Refactor ("Три попытки, и ты рефакторишь")  - принцип, который гласит: если вы трижды сталкиваетесь с необходимостью внести одно и то же изменение в ваш код или вы обнаруживаете одну и ту же проблему в трех разных местах, это говорит нам о том, что в разных частях кода хоть и отсутствует дублированный код но существует дублирование знаний. Значит, пора произвести рефакторинг.
## **YAGNI**



